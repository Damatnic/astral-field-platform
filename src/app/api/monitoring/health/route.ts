/**
 * Advanced Health Monitoring Endpoint
 * Comprehensive system health checks with performance metrics
 */

import { NextRequest, NextResponse } from 'next/server';
import { getHealthChecker } from '@/lib/health-checker';
import performanceMonitor from '@/lib/monitoring/performance-monitor';
import { sentryUtils } from '@/lib/monitoring/sentry-config';

export async function GET(request: NextRequest) {
  const startTime = Date.now();
  const { searchParams } = new URL(request.url);
  
  // Query parameters
  const detailed = searchParams.get('detailed') === 'true';
  const service = searchParams.get('service');
  const format = searchParams.get('format') || 'json';
  const includeMetrics = searchParams.get('metrics') === 'true';
  const includeAlerts = searchParams.get('alerts') === 'true';
  
  try {
    // Start performance tracking
    const transaction = sentryUtils.startTransaction('health-check', 'http');
    
    // Get health checker instance
    const healthChecker = getHealthChecker();
    
    // Get specific service health if requested
    if (service) {\n      const serviceHealth = await performanceMonitor.timeFunction(\n        `health_check_${service}`,\n        async () => {\n          switch (service.toLowerCase()) {\n            case 'database':\n              return await healthChecker.checkDatabase();\n            case 'cache':\n              return await healthChecker.checkCache();\n            case 'monitoring':\n              return await healthChecker.checkMonitoring();\n            case 'system':\n              return await healthChecker.checkSystemResources();\n            case 'apis':\n              return await healthChecker.checkExternalAPIs();\n            default:\n              throw new Error(`Unknown service: ${service}`);\n          }\n        },\n        { service }\n      );\n      \n      const response = {\n        success: true,\n        service: serviceHealth,\n        timestamp: new Date().toISOString(),\n        responseTime: Date.now() - startTime,\n      };\n      \n      transaction.finish();\n      return NextResponse.json(response);\n    }\n    \n    // Comprehensive health check\n    const systemHealth = await performanceMonitor.timeFunction(\n      'comprehensive_health_check',\n      () => healthChecker.performComprehensiveHealthCheck()\n    );\n    \n    // Get performance insights if detailed\n    let performanceData = null;\n    if (detailed || includeMetrics) {\n      performanceData = {\n        systemHealth: await performanceMonitor.getSystemHealth(),\n        insights: performanceMonitor.getPerformanceInsights(),\n      };\n    }\n    \n    // Build response\n    const response = {\n      success: true,\n      overall: systemHealth.overall,\n      version: systemHealth.version,\n      uptime: formatUptime(Date.now() - startTime),\n      timestamp: systemHealth.timestamp,\n      responseTime: Date.now() - startTime,\n      \n      // Core health data\n      health: {\n        status: systemHealth.overall,\n        score: calculateHealthScore(systemHealth),\n        checks: systemHealth.checks.length,\n        summary: systemHealth.summary,\n      },\n      \n      // Detailed information\n      ...(detailed && {\n        services: systemHealth.checks,\n        alerts: includeAlerts ? performanceData?.systemHealth.alerts : undefined,\n        performance: performanceData,\n        environment: {\n          nodeVersion: process.version,\n          platform: process.platform,\n          nodeEnv: process.env.NODE_ENV,\n          deployment: {\n            vercel: !!process.env.VERCEL,\n            commitSha: process.env.VERCEL_GIT_COMMIT_SHA,\n            branch: process.env.VERCEL_GIT_COMMIT_REF,\n          },\n        },\n      }),\n      \n      // Metrics data\n      ...(includeMetrics && performanceData && {\n        metrics: {\n          current: performanceData.systemHealth.metrics.slice(0, 20),\n          trends: performanceData.insights.performanceTrends,\n          slowestEndpoints: performanceData.insights.slowestEndpoints,\n          errorRates: performanceData.insights.errorRates,\n        },\n      }),\n    };\n    \n    // Record monitoring metrics\n    performanceMonitor.recordMetric({\n      name: 'health_check_duration',\n      value: Date.now() - startTime,\n      unit: 'milliseconds',\n      tags: {\n        detailed: detailed.toString(),\n        service: service || 'all',\n        status: systemHealth.overall,\n      },\n    });\n    \n    // Determine HTTP status code\n    let statusCode = 200;\n    if (systemHealth.overall === 'unhealthy') {\n      statusCode = 503; // Service Unavailable\n    } else if (systemHealth.overall === 'degraded') {\n      statusCode = 206; // Partial Content\n    }\n    \n    // Handle different response formats\n    if (format === 'text' || format === 'plain') {\n      const textResponse = formatTextResponse(response);\n      transaction.finish();\n      return new NextResponse(textResponse, {\n        status: statusCode,\n        headers: { 'Content-Type': 'text/plain' },\n      });\n    }\n    \n    if (format === 'prometheus') {\n      const metricsResponse = formatPrometheusMetrics(response, performanceData);\n      transaction.finish();\n      return new NextResponse(metricsResponse, {\n        status: 200,\n        headers: { 'Content-Type': 'text/plain' },\n      });\n    }\n    \n    // Default JSON response\n    transaction.finish();\n    return NextResponse.json(response, { status: statusCode });\n    \n  } catch (error) {\n    console.error('Health check error:', error);\n    \n    // Capture error in monitoring\n    sentryUtils.captureError(error as Error, {\n      component: 'health-monitor',\n      feature: 'health-check',\n      extra: {\n        service,\n        detailed,\n        format,\n        duration: Date.now() - startTime,\n      },\n    });\n    \n    performanceMonitor.recordMetric({\n      name: 'health_check_errors',\n      value: 1,\n      unit: 'count',\n      tags: {\n        error_type: (error as Error).name,\n        service: service || 'all',\n      },\n    });\n    \n    const errorResponse = {\n      success: false,\n      status: 'unhealthy',\n      error: 'Health check failed',\n      details: error instanceof Error ? error.message : 'Unknown error',\n      timestamp: new Date().toISOString(),\n      responseTime: Date.now() - startTime,\n    };\n    \n    return NextResponse.json(errorResponse, { status: 503 });\n  }\n}\n\n// HEAD request for simple uptime monitoring\nexport async function HEAD() {\n  try {\n    const healthChecker = getHealthChecker();\n    \n    // Quick database connectivity check\n    const dbHealth = await healthChecker.checkDatabase();\n    \n    if (dbHealth.status === 'unhealthy') {\n      return new NextResponse(null, { status: 503 });\n    }\n    \n    return new NextResponse(null, { status: 200 });\n  } catch {\n    return new NextResponse(null, { status: 503 });\n  }\n}\n\n// Helper functions\nfunction calculateHealthScore(systemHealth: any): number {\n  const { summary } = systemHealth;\n  const totalChecks = summary.total;\n  \n  if (totalChecks === 0) return 0;\n  \n  const healthyWeight = 100;\n  const degradedWeight = 60;\n  const unhealthyWeight = 0;\n  \n  const weightedScore = \n    (summary.healthy * healthyWeight + \n     summary.degraded * degradedWeight + \n     summary.unhealthy * unhealthyWeight) / totalChecks;\n  \n  return Math.round(weightedScore);\n}\n\nfunction formatUptime(milliseconds: number): string {\n  const seconds = Math.floor(milliseconds / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n  \n  if (days > 0) {\n    return `${days}d ${hours % 24}h ${minutes % 60}m`;\n  } else if (hours > 0) {\n    return `${hours}h ${minutes % 60}m ${seconds % 60}s`;\n  } else if (minutes > 0) {\n    return `${minutes}m ${seconds % 60}s`;\n  } else {\n    return `${seconds}s`;\n  }\n}\n\nfunction formatTextResponse(response: any): string {\n  const lines = [\n    `System Health: ${response.overall.toUpperCase()}`,\n    `Health Score: ${response.health.score}/100`,\n    `Response Time: ${response.responseTime}ms`,\n    `Uptime: ${response.uptime}`,\n    `Timestamp: ${response.timestamp}`,\n    '',\n    'Service Summary:',\n    `  Healthy: ${response.health.summary.healthy}`,\n    `  Degraded: ${response.health.summary.degraded}`,\n    `  Unhealthy: ${response.health.summary.unhealthy}`,\n    `  Total: ${response.health.summary.total}`,\n  ];\n  \n  if (response.services) {\n    lines.push('', 'Service Details:');\n    response.services.forEach((service: any) => {\n      lines.push(`  ${service.service}: ${service.status.toUpperCase()} (${service.responseTime}ms)`);\n      if (service.error) {\n        lines.push(`    Error: ${service.error}`);\n      }\n    });\n  }\n  \n  return lines.join('\\n');\n}\n\nfunction formatPrometheusMetrics(response: any, performanceData: any): string {\n  const lines = [\n    '# HELP system_health_score Overall system health score (0-100)',\n    '# TYPE system_health_score gauge',\n    `system_health_score ${response.health.score}`,\n    '',\n    '# HELP system_health_status System health status (0=unhealthy, 1=degraded, 2=healthy)',\n    '# TYPE system_health_status gauge',\n    `system_health_status ${response.overall === 'healthy' ? 2 : response.overall === 'degraded' ? 1 : 0}`,\n    '',\n    '# HELP health_check_response_time Health check response time in milliseconds',\n    '# TYPE health_check_response_time gauge',\n    `health_check_response_time ${response.responseTime}`,\n    '',\n  ];\n  \n  // Add service-specific metrics\n  if (response.services) {\n    lines.push(\n      '# HELP service_health_status Service health status (0=unhealthy, 1=degraded, 2=healthy)',\n      '# TYPE service_health_status gauge'\n    );\n    \n    response.services.forEach((service: any) => {\n      const statusValue = service.status === 'healthy' ? 2 : service.status === 'degraded' ? 1 : 0;\n      lines.push(`service_health_status{service=\"${service.service}\"} ${statusValue}`);\n    });\n    \n    lines.push('');\n    lines.push(\n      '# HELP service_response_time Service response time in milliseconds',\n      '# TYPE service_response_time gauge'\n    );\n    \n    response.services.forEach((service: any) => {\n      lines.push(`service_response_time{service=\"${service.service}\"} ${service.responseTime}`);\n    });\n  }\n  \n  // Add performance metrics if available\n  if (performanceData?.systemHealth?.metrics) {\n    lines.push('', '# Performance Metrics');\n    \n    const recentMetrics = performanceData.systemHealth.metrics.slice(0, 10);\n    const metricsByName = new Map();\n    \n    recentMetrics.forEach((metric: any) => {\n      if (!metricsByName.has(metric.name)) {\n        metricsByName.set(metric.name, []);\n      }\n      metricsByName.get(metric.name).push(metric);\n    });\n    \n    metricsByName.forEach((metrics, name) => {\n      const latest = metrics[metrics.length - 1];\n      const metricName = name.replace(/[^a-zA-Z0-9_]/g, '_');\n      \n      lines.push(\n        `# HELP ${metricName} ${name} metric`,\n        `# TYPE ${metricName} gauge`,\n        `${metricName} ${latest.value}`\n      );\n    });\n  }\n  \n  return lines.join('\\n');\n}"